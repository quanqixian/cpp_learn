## 1.子类是否可以`直接访问`父类的`私有成员`？

**分析：**

根据面对对象的理论，子类拥有父类的一切属性和行为，因此推测子类`能够直接访问`父类的私有成员

![img](D:\share-opencv\44_继承中的访问级别\pic\slide3.png)

根据c++的语法，外接不能直接访问类的private成员，因此推测子类`不能直接访问`父类的私有成员

![img](D:\share-opencv\44_继承中的访问级别\pic\slide3-2.png)

从两个角度分析，推测的结果是不同的，下面通过实验来得出真正的结论：

**编程实验：继承中的访问级别**

```
#include <iostream>
#include <string>

using namespace std;

class Parent
{
private:
    int mv;
public:
    Parent()
    {
        mv = 100;
    }
    
    int value()
    {
        return mv;
    }
};

class Child : public Parent
{
public:
    int addValue(int v)
    {
        mv = mv + v;    // ???? 如何访问父类的非公有成员
    }
};

int main()
{   
    return 0;
}

```

**实验结果：**

编译不通过，

## 2.继承中的访问级别

- 面对对象的访问级别不只是`public`和`private`
- 可以定义`protected`访问级别
- 关键字protected的意义
    - ​	修改的成员不能被外界直接访问
    - ​	修改的成员可以被`子类直接访问`

**编程实验：protected的使用**



思考：为什么面向对象中需要protected？



定义类时访问级别的选择

![img](D:\share-opencv\44_继承中的访问级别\pic\slide8.png)

组合与继承的综合实例

![img](D:\share-opencv\44_继承中的访问级别\pic\slide9.png)





**编程实验：综合实例** 

## 总结

面向对象中的访问级别不只是public和private

protected修饰的成员不能被外界所访问

protected使得子类能够访问父类的成员

protected关键字是为了继承而专门设计的

没有protected就无法完成真正意义上的代码复用